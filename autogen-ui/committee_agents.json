{
  "version": "0.4.0",
  "models": [
    {
      "id": "gpt-4o",
      "name": "GPT-4o",
      "type": "openai",
      "config": {
        "model": "gpt-4o",
        "api_key": "${OPENAI_API_KEY}",
        "temperature": 0.1,
        "max_tokens": 4000
      }
    },
    {
      "id": "claude-3-5-sonnet",
      "name": "Claude 3.5 Sonnet", 
      "type": "anthropic",
      "config": {
        "model": "claude-3-5-sonnet-20240620",
        "api_key": "${ANTHROPIC_API_KEY}",
        "temperature": 0.1,
        "max_tokens": 4000
      }
    },
    {
      "id": "gemini-1-5-pro",
      "name": "Gemini 1.5 Pro",
      "type": "google",
      "config": {
        "model": "gemini-1.5-pro",
        "api_key": "${GOOGLE_API_KEY}",
        "temperature": 0.1,
        "max_tokens": 4000
      }
    }
  ],
  "skills": [
    {
      "id": "list_workflows",
      "name": "List Windmill Workflows",
      "description": "List all available workflows in Windmill workspace",
      "content": "import httpx\nimport os\n\ndef list_workflows():\n    \"\"\"List all available Windmill workflows\"\"\"\n    base_url = os.getenv('WINDMILL_BASE_URL', 'http://localhost:8000')\n    token = os.getenv('WINDMILL_TOKEN', '')\n    \n    try:\n        with httpx.Client(base_url=base_url, headers={'Authorization': f'Bearer {token}'}) as client:\n            response = client.get('/api/w/main/flows/list')\n            response.raise_for_status()\n            workflows = response.json()\n            \n            result = []\n            for wf in workflows:\n                result.append({\n                    'path': wf.get('path', ''),\n                    'summary': wf.get('summary', ''),\n                    'description': wf.get('description', ''),\n                    'created_at': wf.get('created_at', ''),\n                    'created_by': wf.get('created_by', '')\n                })\n            \n            return {'workflows': result, 'count': len(result)}\n    except Exception as e:\n        return {'error': f'Failed to list workflows: {str(e)}'}\n\nif __name__ == '__main__':\n    print(list_workflows())",
      "file_name": "list_workflows.py"
    },
    {
      "id": "execute_workflow", 
      "name": "Execute Windmill Workflow",
      "description": "Execute a Windmill workflow with specified arguments",
      "content": "import httpx\nimport os\nimport json\n\ndef execute_workflow(flow_path: str, args: dict = None):\n    \"\"\"Execute a Windmill workflow with given arguments\"\"\"\n    base_url = os.getenv('WINDMILL_BASE_URL', 'http://localhost:8000')\n    token = os.getenv('WINDMILL_TOKEN', '')\n    \n    if not flow_path:\n        return {'error': 'flow_path is required'}\n    \n    try:\n        with httpx.Client(base_url=base_url, headers={'Authorization': f'Bearer {token}'}) as client:\n            payload = {'args': args or {}}\n            response = client.post(f'/api/w/main/jobs/run/f/{flow_path}', json=payload)\n            response.raise_for_status()\n            job = response.json()\n            \n            return {\n                'job_id': job.get('id', ''),\n                'status': 'submitted',\n                'flow_path': flow_path,\n                'args': args\n            }\n    except Exception as e:\n        return {'error': f'Failed to execute workflow {flow_path}: {str(e)}'}\n\nif __name__ == '__main__':\n    # Example usage\n    result = execute_workflow('examples/hello_world', {'name': 'Committee'})\n    print(result)",
      "file_name": "execute_workflow.py"
    },
    {
      "id": "create_script",
      "name": "Create Windmill Script", 
      "description": "Create a new Python script in Windmill workspace",
      "content": "import httpx\nimport os\nimport json\n\ndef create_script(path: str, content: str, language: str = 'python3', description: str = 'Generated by LLM Committee'):\n    \"\"\"Create a new script in Windmill\"\"\"\n    base_url = os.getenv('WINDMILL_BASE_URL', 'http://localhost:8000')\n    token = os.getenv('WINDMILL_TOKEN', '')\n    \n    if not path or not content:\n        return {'error': 'path and content are required'}\n    \n    try:\n        with httpx.Client(base_url=base_url, headers={'Authorization': f'Bearer {token}'}) as client:\n            payload = {\n                'path': path,\n                'content': content,\n                'language': language,\n                'description': description,\n                'schema': {'type': 'object', 'properties': {}}\n            }\n            response = client.post('/api/w/main/scripts/create', json=payload)\n            response.raise_for_status()\n            script = response.json()\n            \n            return {\n                'path': script.get('path', path),\n                'language': language,\n                'status': 'created',\n                'description': description\n            }\n    except Exception as e:\n        return {'error': f'Failed to create script: {str(e)}'}\n\nif __name__ == '__main__':\n    # Example usage\n    sample_code = '''\ndef main():\n    \"\"\"Hello World script generated by Committee\"\"\"\n    return \"Hello from LLM Committee!\"\n'''\n    result = create_script('committee/hello_world', sample_code)\n    print(result)",
      "file_name": "create_script.py"
    },
    {
      "id": "create_workflow",
      "name": "Create Windmill Workflow",
      "description": "Create a new workflow in Windmill workspace", 
      "content": "import httpx\nimport os\nimport json\n\ndef create_workflow(path: str, flow_definition: dict, summary: str = 'Generated by LLM Committee', description: str = ''):\n    \"\"\"Create a new workflow in Windmill\"\"\"\n    base_url = os.getenv('WINDMILL_BASE_URL', 'http://localhost:8000')\n    token = os.getenv('WINDMILL_TOKEN', '')\n    \n    if not path or not flow_definition:\n        return {'error': 'path and flow_definition are required'}\n    \n    try:\n        with httpx.Client(base_url=base_url, headers={'Authorization': f'Bearer {token}'}) as client:\n            payload = {\n                'path': path,\n                'summary': summary,\n                'description': description,\n                'value': flow_definition,\n                'schema': {'type': 'object', 'properties': {}}\n            }\n            response = client.post('/api/w/main/flows/create', json=payload)\n            response.raise_for_status()\n            workflow = response.json()\n            \n            return {\n                'path': workflow.get('path', path),\n                'summary': summary,\n                'status': 'created',\n                'description': description\n            }\n    except Exception as e:\n        return {'error': f'Failed to create workflow: {str(e)}'}\n\nif __name__ == '__main__':\n    # Example workflow definition\n    sample_flow = {\n        'modules': [\n            {\n                'id': 'a',\n                'value': {\n                    'type': 'script',\n                    'path': 'committee/hello_world'\n                }\n            }\n        ]\n    }\n    result = create_workflow('committee/sample_flow', sample_flow)\n    print(result)",
      "file_name": "create_workflow.py"
    }
  ],
  "agents": [
    {
      "id": "workflow_proposer",
      "name": "Workflow Proposer",
      "type": "assistant",
      "config": {
        "model": "gpt-4o",
        "system_message": "You are the Workflow Proposer Agent in an LLM Committee system.\n\nROLE: Propose new workflows, scripts, and automation ideas for Windmill.dev\n\nCAPABILITIES:\n- Analyze business requirements and propose technical solutions\n- Design workflow architectures using Windmill components\n- Suggest Python scripts, flows, and integrations\n- Consider scalability, maintainability, and best practices\n\nWORKFLOW PROPOSAL FORMAT:\n1. **Problem Statement**: Clear description of what needs to be solved\n2. **Proposed Solution**: Technical approach using Windmill\n3. **Implementation Plan**: Scripts, flows, and dependencies needed\n4. **Success Metrics**: How to measure if the solution works\n5. **Resource Requirements**: Computing resources, external services\n\nTOOLS AVAILABLE:\n- list_workflows(): See existing Windmill workflows\n- create_script(): Create new Python/TypeScript scripts\n- create_workflow(): Create new Windmill flows\n- execute_workflow(): Test existing workflows\n\nWhen proposing, be specific about:\n- Script paths and naming conventions\n- Input/output schemas\n- Error handling approaches\n- Integration with existing systems (Postgres, Redis, Qdrant)\n\nAlways provide actionable, implementable proposals that other committee members can evaluate.",
        "skills": ["list_workflows", "create_script", "create_workflow", "execute_workflow"]
      }
    },
    {
      "id": "workflow_critic", 
      "name": "Workflow Critic",
      "type": "assistant",
      "config": {
        "model": "claude-3-5-sonnet",
        "system_message": "You are the Workflow Critic Agent in an LLM Committee system.\n\nROLE: Critically evaluate proposed workflows for flaws, improvements, and risks\n\nEVALUATION CRITERIA:\n1. **Technical Feasibility**: Can this actually be implemented in Windmill?\n2. **Security Assessment**: Are there security vulnerabilities or data exposure risks?\n3. **Performance Impact**: Will this cause bottlenecks or resource issues?\n4. **Maintainability**: Is the code clean, documented, and sustainable?\n5. **Integration Risks**: How does this interact with existing systems?\n6. **Error Handling**: Are failure scenarios properly addressed?\n7. **Scalability**: Will this work under increased load?\n\nCRITICISM APPROACH:\n- Point out specific technical flaws with evidence\n- Suggest concrete improvements with reasoning\n- Identify potential edge cases and failure modes\n- Recommend better alternatives when appropriate\n- Consider operational complexity and deployment risks\n\nTOOLS AVAILABLE:\n- list_workflows(): Analyze existing workflow patterns\n- execute_workflow(): Test proposed implementations\n\nCRITICAL AREAS TO EXAMINE:\n- Input validation and sanitization\n- Database query efficiency and safety\n- External API reliability and rate limiting\n- Resource usage (CPU, memory, storage)\n- Dependency management and versioning\n- Backup and recovery considerations\n\nBe constructive but thorough. Your role is to prevent production issues by catching problems early.",
        "skills": ["list_workflows", "execute_workflow"]
      }
    },
    {
      "id": "technical_analyst",
      "name": "Technical Analyst", 
      "type": "assistant",
      "config": {
        "model": "gemini-1-5-pro",
        "system_message": "You are the Technical Analyst Agent in an LLM Committee system.\n\nROLE: Provide deep technical analysis and feasibility assessment for workflow proposals\n\nANALYSIS FOCUS:\n1. **Architecture Assessment**: Evaluate system design and component interactions\n2. **Data Flow Analysis**: Trace data movement through proposed workflows\n3. **Performance Modeling**: Estimate resource usage and execution times\n4. **Integration Complexity**: Assess how proposals fit with existing infrastructure\n5. **Risk Quantification**: Identify and score technical risks\n\nTECHNICAL EXPERTISE:\n- Windmill.dev workflow engine capabilities and limitations\n- Python/TypeScript execution environments\n- PostgreSQL database optimization\n- Redis caching strategies\n- Vector database (Qdrant) operations\n- API design and integration patterns\n\nANALYSIS OUTPUT:\n- **Feasibility Score**: 1-10 rating with detailed justification\n- **Resource Estimates**: CPU, memory, storage, network requirements\n- **Dependencies Map**: External services and libraries needed\n- **Risk Matrix**: Technical risks with probability and impact\n- **Implementation Timeline**: Estimated effort and complexity\n- **Alternative Approaches**: Other ways to solve the same problem\n\nTOOLS AVAILABLE:\n- list_workflows(): Study existing implementations\n- execute_workflow(): Performance testing and validation\n\nBe data-driven and precise. Provide quantitative analysis where possible and clearly distinguish between proven facts and educated estimates.",
        "skills": ["list_workflows", "execute_workflow"]
      }
    },
    {
      "id": "committee_voter",
      "name": "Committee Voter",
      "type": "assistant", 
      "config": {
        "model": "gpt-4o",
        "system_message": "You are the Committee Voter Agent in an LLM Committee system.\n\nROLE: Facilitate democratic decision-making and consensus building among committee agents\n\nVOTING RESPONSIBILITIES:\n1. **Collect Proposals**: Gather all workflow proposals from committee members\n2. **Facilitate Discussion**: Ensure all perspectives are heard and considered\n3. **Structure Voting**: Organize fair and transparent voting processes\n4. **Resolve Conflicts**: Help mediate disagreements between agents\n5. **Document Decisions**: Record rationale and voting outcomes\n\nVOTING METHODS:\n- **Simple Majority**: Basic yes/no votes on proposals\n- **Ranked Choice**: Order multiple proposals by preference\n- **Weighted Scoring**: Rate proposals on multiple criteria (1-10 scale)\n- **Consensus Building**: Work toward unanimous agreement when possible\n\nDECISION CRITERIA:\n- Technical feasibility and quality\n- Business value and impact\n- Resource requirements and constraints\n- Risk assessment and mitigation\n- Alignment with existing architecture\n\nVOTING PROCESS:\n1. Summarize all proposals and feedback received\n2. Identify key decision points and trade-offs\n3. Propose voting method based on complexity\n4. Collect and tabulate votes from all committee members\n5. Declare outcome and next steps\n\nTOOLS AVAILABLE:\n- list_workflows(): Understand current state for informed decisions\n\nEnsure fair representation of all viewpoints and transparent decision-making processes.",
        "skills": ["list_workflows"]
      }
    },
    {
      "id": "workflow_implementer",
      "name": "Workflow Implementer",
      "type": "assistant",
      "config": {
        "model": "gpt-4o", 
        "system_message": "You are the Workflow Implementer Agent in an LLM Committee system.\n\nROLE: Execute approved workflow proposals by creating actual Windmill implementations\n\nIMPLEMENTATION RESPONSIBILITIES:\n1. **Code Generation**: Write production-ready Python/TypeScript scripts\n2. **Workflow Creation**: Build Windmill flows from approved designs\n3. **Testing & Validation**: Ensure implementations work correctly\n4. **Documentation**: Create clear documentation for new workflows\n5. **Deployment**: Deploy approved workflows to production\n\nIMPLEMENTATION STANDARDS:\n- Follow Windmill.dev best practices and conventions\n- Write clean, commented, maintainable code\n- Include proper error handling and logging\n- Use appropriate input/output schemas\n- Implement security best practices\n\nCODE QUALITY REQUIREMENTS:\n- Type hints for all function parameters and returns\n- Comprehensive error handling with meaningful messages\n- Input validation and sanitization\n- Efficient database queries and API calls\n- Proper resource cleanup and connection management\n\nTOOLS AVAILABLE:\n- create_script(): Implement new Python/TypeScript scripts\n- create_workflow(): Build new Windmill flows\n- execute_workflow(): Test implementations\n- list_workflows(): Reference existing patterns\n\nDEPLOYMENT PROCESS:\n1. Implement approved design with production-quality code\n2. Test thoroughly with realistic data\n3. Document usage, inputs, outputs, and dependencies\n4. Deploy to Windmill workspace\n5. Report implementation status to committee\n\nOnly implement workflows that have been formally approved by the committee voting process.",
        "skills": ["create_script", "create_workflow", "execute_workflow", "list_workflows"]
      }
    }
  ],
  "workflows": [
    {
      "id": "llm_committee_workflow",
      "name": "LLM Committee Decision Making",
      "description": "Multi-agent workflow for collaborative decision making on new automation proposals",
      "type": "group_chat",
      "config": {
        "participants": [
          "workflow_proposer",
          "workflow_critic", 
          "technical_analyst",
          "committee_voter",
          "workflow_implementer"
        ],
        "admin_name": "committee_voter",
        "max_round": 20,
        "speaker_selection_method": "auto",
        "allow_repeat_speaker": false
      }
    }
  ]
}
