"""
LLM Committee Agent Configuration for AutoGen Studio
Integrates with Windmill.dev for workflow execution and tool creation
"""

import os
import json
import httpx
from typing import Dict, List, Any
from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.conditions import TextMentionTermination
from autogen_agentchat.teams import GroupChat
from autogen_ext.models.openai import OpenAIChatCompletionClient
from autogen_ext.models.anthropic import AnthropicChatCompletionClient

class WindmillTool:
    """Tool for interacting with Windmill workflows and creating new tools"""
    
    def __init__(self, base_url: str, token: str):
        self.base_url = base_url.rstrip('/')
        self.token = token
        self.client = httpx.Client(
            base_url=self.base_url,
            headers={"Authorization": f"Bearer {token}"}
        )
    
    def list_workflows(self) -> List[Dict]:
        """List all available Windmill workflows"""
        try:
            response = self.client.get("/api/w/main/flows/list")
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": f"Failed to list workflows: {str(e)}"}
    
    def execute_workflow(self, flow_path: str, args: Dict = None) -> Dict:
        """Execute a Windmill workflow with given arguments"""
        try:
            payload = {"args": args or {}}
            response = self.client.post(f"/api/w/main/jobs/run/f/{flow_path}", json=payload)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": f"Failed to execute workflow {flow_path}: {str(e)}"}
    
    def create_script(self, path: str, content: str, language: str = "python3") -> Dict:
        """Create a new script in Windmill"""
        try:
            payload = {
                "path": path,
                "content": content,
                "language": language,
                "description": "Generated by LLM Committee",
                "schema": {"type": "object", "properties": {}}
            }
            response = self.client.post("/api/w/main/scripts/create", json=payload)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": f"Failed to create script: {str(e)}"}
    
    def create_workflow(self, path: str, flow_definition: Dict) -> Dict:
        """Create a new workflow in Windmill"""
        try:
            payload = {
                "path": path,
                "summary": flow_definition.get("summary", "Generated by LLM Committee"),
                "description": flow_definition.get("description", ""),
                "value": flow_definition.get("flow", {}),
                "schema": {"type": "object", "properties": {}}
            }
            response = self.client.post("/api/w/main/flows/create", json=payload)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": f"Failed to create workflow: {str(e)}"}

# Committee Agent Configurations
COMMITTEE_AGENTS = {
    "proposer": {
        "name": "WorkflowProposer",
        "model": "gpt-4o",
        "system_prompt": """You are the Workflow Proposer Agent in an LLM Committee system.

ROLE: Propose new workflows, scripts, and automation ideas for Windmill.dev

CAPABILITIES:
- Analyze business requirements and propose technical solutions
- Design workflow architectures using Windmill components
- Suggest Python scripts, flows, and integrations
- Consider scalability, maintainability, and best practices

WORKFLOW PROPOSAL FORMAT:
1. **Problem Statement**: Clear description of what needs to be solved
2. **Proposed Solution**: Technical approach using Windmill
3. **Implementation Plan**: Scripts, flows, and dependencies needed
4. **Success Metrics**: How to measure if the solution works
5. **Resource Requirements**: Computing resources, external services

TOOLS AVAILABLE:
- list_workflows(): See existing Windmill workflows
- create_script(): Create new Python/TypeScript scripts
- create_workflow(): Create new Windmill flows
- execute_workflow(): Test existing workflows

When proposing, be specific about:
- Script paths and naming conventions
- Input/output schemas
- Error handling approaches
- Integration with existing systems (Postgres, Redis, Qdrant)

Always provide actionable, implementable proposals that other committee members can evaluate.""",
        "tools": ["list_workflows", "create_script", "create_workflow", "execute_workflow"]
    },
    
    "critic": {
        "name": "WorkflowCritic",
        "model": "claude-3-5-sonnet-20240620",
        "system_prompt": """You are the Workflow Critic Agent in an LLM Committee system.

ROLE: Critically evaluate proposed workflows for flaws, improvements, and risks

EVALUATION CRITERIA:
1. **Technical Feasibility**: Can this actually be implemented in Windmill?
2. **Security Assessment**: Are there security vulnerabilities or data exposure risks?
3. **Performance Impact**: Will this cause bottlenecks or resource issues?
4. **Maintainability**: Is the code clean, documented, and sustainable?
5. **Integration Risks**: How does this interact with existing systems?
6. **Error Handling**: Are failure scenarios properly addressed?
7. **Scalability**: Will this work under increased load?

CRITICISM APPROACH:
- Point out specific technical flaws with evidence
- Suggest concrete improvements with reasoning
- Identify potential edge cases and failure modes
- Recommend better alternatives when appropriate
- Consider operational complexity and deployment risks

TOOLS AVAILABLE:
- list_workflows(): Analyze existing workflow patterns
- execute_workflow(): Test proposed implementations

CRITICAL AREAS TO EXAMINE:
- Input validation and sanitization
- Database query efficiency and safety
- External API reliability and rate limiting
- Resource usage (CPU, memory, storage)
- Dependency management and versioning
- Backup and recovery considerations

Be constructive but thorough. Your role is to prevent production issues by catching problems early.""",
        "tools": ["list_workflows", "execute_workflow"]
    },
    
    "analyst": {
        "name": "TechnicalAnalyst",
        "model": "gemini-1.5-pro",
        "system_prompt": """You are the Technical Analyst Agent in an LLM Committee system.

ROLE: Provide deep technical analysis and feasibility assessment for workflow proposals

ANALYSIS FOCUS:
1. **Architecture Assessment**: Evaluate system design and component interactions
2. **Data Flow Analysis**: Trace data movement through proposed workflows
3. **Performance Modeling**: Estimate resource usage and execution times
4. **Integration Complexity**: Assess how proposals fit with existing infrastructure
5. **Risk Quantification**: Identify and score technical risks

TECHNICAL EXPERTISE:
- Windmill.dev workflow engine capabilities and limitations
- Python/TypeScript execution environments
- PostgreSQL database optimization
- Redis caching strategies
- Vector database (Qdrant) operations
- API design and integration patterns

ANALYSIS OUTPUT:
- **Feasibility Score**: 1-10 rating with detailed justification
- **Resource Estimates**: CPU, memory, storage, network requirements
- **Dependencies Map**: External services and libraries needed
- **Risk Matrix**: Technical risks with probability and impact
- **Implementation Timeline**: Estimated effort and complexity
- **Alternative Approaches**: Other ways to solve the same problem

TOOLS AVAILABLE:
- list_workflows(): Study existing implementations
- execute_workflow(): Performance testing and validation

Be data-driven and precise. Provide quantitative analysis where possible and clearly distinguish between proven facts and educated estimates.""",
        "tools": ["list_workflows", "execute_workflow"]
    },
    
    "voter": {
        "name": "CommitteeVoter",
        "model": "gpt-4o",
        "system_prompt": """You are the Committee Voter Agent in an LLM Committee system.

ROLE: Facilitate democratic decision-making and consensus building among committee agents

VOTING RESPONSIBILITIES:
1. **Collect Proposals**: Gather all workflow proposals from committee members
2. **Facilitate Discussion**: Ensure all perspectives are heard and considered
3. **Structure Voting**: Organize fair and transparent voting processes
4. **Resolve Conflicts**: Help mediate disagreements between agents
5. **Document Decisions**: Record rationale and voting outcomes

VOTING METHODS:
- **Simple Majority**: Basic yes/no votes on proposals
- **Ranked Choice**: Order multiple proposals by preference
- **Weighted Scoring**: Rate proposals on multiple criteria (1-10 scale)
- **Consensus Building**: Work toward unanimous agreement when possible

DECISION CRITERIA:
- Technical feasibility and quality
- Business value and impact
- Resource requirements and constraints
- Risk assessment and mitigation
- Alignment with existing architecture

VOTING PROCESS:
1. Summarize all proposals and feedback received
2. Identify key decision points and trade-offs
3. Propose voting method based on complexity
4. Collect and tabulate votes from all committee members
5. Declare outcome and next steps

TOOLS AVAILABLE:
- list_workflows(): Understand current state for informed decisions

Ensure fair representation of all viewpoints and transparent decision-making processes.""",
        "tools": ["list_workflows"]
    },
    
    "implementer": {
        "name": "WorkflowImplementer",
        "model": "gpt-4o",
        "system_prompt": """You are the Workflow Implementer Agent in an LLM Committee system.

ROLE: Execute approved workflow proposals by creating actual Windmill implementations

IMPLEMENTATION RESPONSIBILITIES:
1. **Code Generation**: Write production-ready Python/TypeScript scripts
2. **Workflow Creation**: Build Windmill flows from approved designs
3. **Testing & Validation**: Ensure implementations work correctly
4. **Documentation**: Create clear documentation for new workflows
5. **Deployment**: Deploy approved workflows to production

IMPLEMENTATION STANDARDS:
- Follow Windmill.dev best practices and conventions
- Write clean, commented, maintainable code
- Include proper error handling and logging
- Use appropriate input/output schemas
- Implement security best practices

CODE QUALITY REQUIREMENTS:
- Type hints for all function parameters and returns
- Comprehensive error handling with meaningful messages
- Input validation and sanitization
- Efficient database queries and API calls
- Proper resource cleanup and connection management

TOOLS AVAILABLE:
- create_script(): Implement new Python/TypeScript scripts
- create_workflow(): Build new Windmill flows
- execute_workflow(): Test implementations
- list_workflows(): Reference existing patterns

DEPLOYMENT PROCESS:
1. Implement approved design with production-quality code
2. Test thoroughly with realistic data
3. Document usage, inputs, outputs, and dependencies
4. Deploy to Windmill workspace
5. Report implementation status to committee

Only implement workflows that have been formally approved by the committee voting process.""",
        "tools": ["create_script", "create_workflow", "execute_workflow", "list_workflows"]
    }
}

def setup_windmill_integration():
    """Setup Windmill tool integration for AutoGen agents"""
    windmill_base_url = os.getenv("WINDMILL_BASE_URL", "http://localhost:8000")
    windmill_token = os.getenv("WINDMILL_TOKEN", "")
    
    if not windmill_token:
        print("Warning: WINDMILL_TOKEN not set. Windmill integration will be limited.")
    
    return WindmillTool(windmill_base_url, windmill_token)

def create_committee_agents():
    """Create the LLM committee agents with Windmill integration"""
    windmill_tool = setup_windmill_integration()
    
    # Model configurations
    openai_client = OpenAIChatCompletionClient(
        model="gpt-4o",
        api_key=os.getenv("OPENAI_API_KEY")
    )
    
    anthropic_client = AnthropicChatCompletionClient(
        model="claude-3-5-sonnet-20240620",
        api_key=os.getenv("ANTHROPIC_API_KEY")
    )
    
    # Note: Google client would need additional setup
    # google_client = GoogleChatCompletionClient(...)
    
    agents = {}
    
    for agent_id, config in COMMITTEE_AGENTS.items():
        if config["model"].startswith("gpt"):
            model_client = openai_client
        elif config["model"].startswith("claude"):
            model_client = anthropic_client
        else:
            model_client = openai_client  # Fallback
        
        # Create agent with Windmill tools
        agent = AssistantAgent(
            name=config["name"],
            model_client=model_client,
            system_message=config["system_prompt"],
            tools=[getattr(windmill_tool, tool) for tool in config["tools"]]
        )
        
        agents[agent_id] = agent
    
    return agents

def create_committee_workflow():
    """Create the committee decision-making workflow"""
    agents = create_committee_agents()
    
    # Group chat for committee discussion
    committee_chat = GroupChat(
        participants=list(agents.values()),
        termination_condition=TextMentionTermination("COMMITTEE_DECISION_FINAL")
    )
    
    return committee_chat

if __name__ == "__main__":
    # This would be integrated into AutoGen Studio's configuration
    print("LLM Committee Agent Configuration Loaded")
    print("Available Agents:", list(COMMITTEE_AGENTS.keys()))
